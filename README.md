# ESP Hosted
For connecting to an [ESP-Hosted-MCU](https://github.com/espressif/esp-hosted-mcu) from a Host MCU with firmware
written in rust.

Compatible with ESP-Hosted-MCU 2.0.6, and any host MCU and architecture. For details on ESP-HOSTED-MCU's protocol see
[this document](/esp_hosted_protocol.md). For how to use the commands in the library effectively, reference the
[ESP32 IDF programming guide](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/index.html)

This library includes two approaches: A high-level API using data structures from this library, and full access to 
the native protobuf structures. The native API is easier to work with, but only implements a small portation of functionality.
The protobuf API is complete, but more cumbersome.

Example use:
```rust
fn init(buf: &mut [u8], uart: &mut Uart) {
    // Write could also be SPI, dma etc.
    let mut write = |buf: &[u8]| {
        uart.write(buf).map_err(|e| {
            println!("Uart write error: {:?}", e);
            EspError::Comms
        })
    };

    let heartbeat_cfg = RpcReqConfigHeartbeat {
        enable: true,
        duration: 10,
    };

    esp_hosted::cfg_heartbeat(buf, &mut write, &heartbeat_cfg).is_err()?;
}
```

In your UART, SPI etc reception handling (e.g. an interrupt handler), you can parse incoming messages from the Esp. 
The `parse_msg` function returns a struct containing the following:
- The payload header. This contains generic data, and you may not need to use it.
- A struct from this library containing the RPC header. This determines if a request, response, or event, and the Rpc ID being  used.
- The rpc payload, as a `&[u8]`
- A struct generated by the `micropb` library, which contains the full RPC data, in a raw format. 


```rust
#[interrupt]
fn USART2() {
    // ...
    match esp_hosted::parse_msg(rx_buf) {
        Ok(msg) => {
            println!("\nHeader: {:?}", msg.header);
            println!("RPC: {:?}", msg.rpc);
            println!("Data buf: {:?}", msg.data_buf);
            
            if rpc.msg_id == RpcId::EventHeartbeat {
                // A/R. You could then parse `data_buf` into the appropriate response type.
            }
        }
    }
}
```

To perform specific actions, there are functions like `wifi_get_protocol`,  `wifi_start`, `get_wifi_mode` etc. There
take a `write` fn and `uid` as parameters, and others on a per-message basis. These are set up using structs that
are part of this library.

These only cover a small portion of available functionality. To get the full functionality, create a `RpcP` struct, then 
pass it, and a write fn to the `write_rpc_proto`. Constructing these `RpcP` structs is done IOC the `micropb` lib. Here's
an example, using the same heartbeat config as above. This is more verbose than our high-level API, but is much more flexible:

```rust
    use esp_hosted::{RpcP, RpcTypeP, RpcIdP, Rpc_};

    fn init(buf: &mut [u8], uart: &mut Uart) {
        // let write = ... (Same as above)
        
        let mut hb_msg = RpcP::default();
        hb_msg.uid = 0;
        hb_msg.msg_type = RpcTypeP::Req;
        hb_msg.msg_id = RpcIdP::ReqConfigHeartbeat;

        let mut hb_cfg = Rpc_Req_ConfigHeartbeat::default();
        hb_cfg.enable = true;
        hb_cfg.duration = 10;

        hb_msg.payload = Some(Rpc_::Payload::ReqConfigHeartbeat(hb_cfg));

        esp_hosted::write_rpc_proto(buf, &mut write, hb_msg)?;
    }
```


### Building the proto file
This is not required if installing from crates.io; only applicable if working with the source directly.

The module `esp_hosted_proto.rs` is not included directly in the source code; it's built from 
[esp_hosted_rpc.proto](https://github.com/espressif/esp-hosted-mcu/blob/main/common/proto/esp_hosted_rpc.proto).

To build it:

- **1**: Install the [protoc](https://grpc.io/docs/protoc-installation/) application, and place its on your system's path.

- **2:** Run the `build_proto` sub application with `cargo run` from its directory. This will place `esp_hosed_proto.rs` 
- in this program's `src` folder.